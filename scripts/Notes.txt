Smart contact detection: 
    Initialization:
        this is done before runtime, so no real time concerns, but can't take hours obvoiusly
        In 2D, start from the first node and check distances, go until you find penetration
        Then check that section for centre of contact, then the next section, and the next, until you're out of the range of tyre bounding box
        Centre of contact is just the closest point.

        We're trying to avoid doing a brute force search over a whole section's points. 
        We're also trying to avoid representing a section as just one circle with a radius, but that migh be ok as long as the section is small enough
        Make sure things like sharp angles don't get filtered away. 

        For now:
            Find the first penetrating point
            Hand over to the section owning that poing. The section will find its centre and return next section if there's still possibility of contact
            possibility of contact: start point is in bounding box. 
            do this until no possibility of contact 
            QUESTION: how do you deal with convext and concave sections. Does it make a difference if the starting section is of either constraint_type
            ANSWER: For now let's check all consecutive sections we'll see about concave sections later
            QUESTION: How about interfering contacts. All the points inside the deflected section ofthe previous contact
	    ANSWER**: THERE ARE NONE. barring the initialization step, 


every following step the movement has been so small that any contact 
detected is limited to that convex section only. So if contacts in 
different sections are discovered, they are definitely separate contacts. 

	 Concerns about the tread layer:
    Kim uses the tread layer as a buffer between the belt and the ground. We're just merrily ignoring it
    The thing about the tread element is outside the contact region it's uncompressed, so it can be ignored
    so whatever we're doing outside of the contact is find, same as in tire mechanics. in the contact section though, 
    Kim solves a system of equations which makes sure there's force balance between the tread elements and the belt layer
    which means iterative. We're only doing it for a circle, so we should be able to find a closed form formula for it
    Let's go with what we have for now, do the deflection based on the belt, in the contact section, 
    "FIND THE DISTRIBUTION BASED ON THE DEFLECTION OF THE BELT, SO AT THE BOUNDARIES IT GOES DOWN TO 0",
    *Solve the differential equation for the radial beam later             
Monday, 31st Jul:
    Do the terrain filtering, i.e. fit a circle that passes through 3 poins;
        start, end and the peak
    then the contact with the section will be a contact with a circle and very quickly resolved

    In some of the sections, the peak node is the same as the start or end node, we skip those cases for now, have to deal with them later 
    for the step, the circle is predictibly not as sharp, but this can be remedied by maybe shortening the filter window. either way it's accepetable and much faster
    OR:
    keep the same two circle solution, but use the end and start node of the section as your boudnaries
    When cleaning up the section, if you remove one section, you'll have to shift all the following section numbers by 1, not just the immediate next section. (how did you miss that you idiot)
Tuesday 1st Aug: 
    Using start and end of the section helps make the circles more continous and the changes les jumpy, but could still ignore the peaks. We fall back on the filtering algorithm, where we simply use the fitted circle as the terrain profile. This inevitably filters out the sharp corners, we turn the filtering window down to 1 cm, so the smallest detectible radius is 1 cm which should be okay. 
Wednesday 2nd Aug:
    Problem with a small filtering windows is it accounts for every little detail on the road surface. while those details might be there, they massively complicate the contact detection process. Today, I'll keep the filtering the same, so keeping the same little sections, but try to implement a contact detection method that is not sensitive the those, i.e. if all the little contacts turn out to belong to the same surface, we take that to be one contact. 
    Algorithm:
        Start with a tyre not in contact, as this might happen during the run anyway, we need to be able to resolve it in real time. 
        Detect the penetrating points using a tree (not necessirily implemented here), 
    What I did with sectioning was a bit of a hack. Need to consider flat sections too. 
Thursday 3rd Aug: 
    Problems remaining: 
        A formulation to take into account the tread elements
        A formulation for multiple contacts
        Solution for multiple contact: use the fitted circles to terrain sections, and jump from one section to the next.